<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ–‡ä»¶æƒæå·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 40px;
        }

        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 60px 20px;
            background: #fafafa;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #e8f2ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            color: #667eea;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #555;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #888;
            font-size: 0.9rem;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            min-width: 120px;
            height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff7b7b 0%, #ff416c 100%);
        }

        .processing-section {
            display: none;
            margin: 30px 0;
        }

        .progress-bar {
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 8px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .status-text {
            text-align: center;
            color: #555;
            font-size: 1.1rem;
        }

        .canvas-section {
            display: none;
            margin: 30px 0;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .canvas-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        canvas {
            max-width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .manual-adjust {
            background: #fff9c4;
            border: 1px solid #f0e68c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .manual-adjust h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .corner-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .corner-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .corner-input label {
            font-weight: bold;
            min-width: 60px;
        }

        .corner-input input {
            flex: 1;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .result-section {
            display: none;
            margin: 30px 0;
            text-align: center;
        }

        .download-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
            min-width: 120px;
            height: 44px;
        }

        .download-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .corner-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff4757;
            border: 2px solid white;
            border-radius: 50%;
            cursor: move;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .corner-marker:hover {
            background: #ff3742;
            transform: translate(-50%, -50%) scale(1.2);
        }

        /* åœ–ç‰‡è¼‰å…¥Spinner */
        .image-loading {
            display: none;
            text-align: center;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
        }

        .image-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .corner-controls {
                grid-template-columns: 1fr;
            }
            
            /* æ—‹è½‰åŠŸèƒ½éŸ¿æ‡‰å¼ */
            .canvas-container div[style*="flex"] {
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            #resultCanvas {
                max-width: 90% !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“„ æ–‡ä»¶æƒæå·¥å…·</h1>
            <p>æ™ºæ…§åµæ¸¬æ–‡ä»¶é‚Šç•Œï¼Œè‡ªå‹•è£åˆ‡é€è¦–æ ¡æ­£</p>
        </div>

        <div class="main-content">
            <!-- ä¸Šå‚³å€åŸŸ -->
            <div class="upload-section">
                <div class="upload-area" onclick="document.getElementById('fileInput').click()" 
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <div class="upload-icon">ğŸ“·</div>
                    <div class="upload-text">é»æ“Šä¸Šå‚³æˆ–æ‹–æ‹½åœ–ç‰‡åˆ°æ­¤è™•</div>
                    <div class="upload-hint">æ”¯æ´ JPGã€PNG æ ¼å¼ï¼Œå»ºè­°æª”æ¡ˆå¤§å°å°æ–¼ 10MB</div>
                </div>
                <input type="file" id="fileInput" accept="image/*" onchange="handleFileSelect(event)">
            </div>

            <!-- åœ–ç‰‡è¼‰å…¥ä¸­ -->
            <div class="image-loading" id="imageLoading">
                <div class="image-spinner"></div>
                <p>æ­£åœ¨è™•ç†ä¸­...</p>
            </div>

            <!-- è™•ç†é€²åº¦ -->
            <div class="processing-section" id="processingSection">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="status-text" id="statusText">æ­£åœ¨è™•ç†åœ–ç‰‡...</div>
            </div>

            <!-- ç•«å¸ƒé¡¯ç¤ºå€åŸŸ -->
            <div class="canvas-section" id="canvasSection">
                <div class="canvas-container">
                    <div class="canvas-title">è¼¸å…¥</div>
                    <div style="position: relative;">
                        <canvas id="detectionCanvas"></canvas>
                        <!-- è§’é»æ¨™è¨˜æœƒå‹•æ…‹æ·»åŠ åˆ°é€™è£¡ -->
                    </div>
                </div>
            </div>

            <!-- æ‰‹å‹•èª¿æ•´å€åŸŸ -->
            <div class="manual-adjust" id="manualAdjust">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">ğŸ”§ æ‰‹å‹•å¾®èª¿è§’é»ä½ç½®</h3>
                    <button class="btn" onclick="autoDetect()">ğŸ”„ è§’é»é‡ç½®</button>
                </div>
                <p>æ‹–æ‹½ç´…è‰²åœ“é»æˆ–è¼¸å…¥ç²¾ç¢ºåº§æ¨™ä¾†èª¿æ•´æ–‡ä»¶é‚Šç•Œ</p>
                
                <div class="corner-controls">
                    <div class="corner-input">
                        <label>å·¦ä¸Šè§’:</label>
                        <input type="number" id="corner0x" placeholder="X" min="0" style="width: 80px;">
                        <input type="number" id="corner0y" placeholder="Y" min="0" style="width: 80px;">
                    </div>
                    <div class="corner-input">
                        <label>å³ä¸Šè§’:</label>
                        <input type="number" id="corner1x" placeholder="X" min="0" style="width: 80px;">
                        <input type="number" id="corner1y" placeholder="Y" min="0" style="width: 80px;">
                    </div>
                    <div class="corner-input">
                        <label>å³ä¸‹è§’:</label>
                        <input type="number" id="corner2x" placeholder="X" min="0" style="width: 80px;">
                        <input type="number" id="corner2y" placeholder="Y" min="0" style="width: 80px;">
                    </div>
                    <div class="corner-input">
                        <label>å·¦ä¸‹è§’:</label>
                        <input type="number" id="corner3x" placeholder="X" min="0" style="width: 80px;">
                        <input type="number" id="corner3y" placeholder="Y" min="0" style="width: 80px;">
                    </div>
                </div>

                <!-- è¼¸å‡ºæ ¼å¼é¸æ“‡ -->
                <div style="margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px;">ğŸ“„ åˆ—å°è¼¸å‡ºæ ¼å¼</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="outputFormat" value="grayscale" checked>
                            <span>âš« ç°éš (çœå¢¨æ°´)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="outputFormat" value="original">
                            <span>ğŸ–¼ï¸ åŸå§‹å½©è‰²</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="outputFormat" value="blackwhite">
                            <span>âšª é»‘ç™½é«˜å°æ¯”</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="outputFormat" value="enhanced">
                            <span>âœ¨ å¢å¼·å°æ¯”åº¦</span>
                        </label>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                        ğŸ’¡ <strong>å»ºè­°</strong>ï¼šæ–‡å­—æ–‡ä»¶é¸ã€Œé»‘ç™½é«˜å°æ¯”ã€æœ€çœå¢¨æ°´ï¼›ç…§ç‰‡é¸ã€Œç°éšã€ï¼›å½©è‰²æ–‡ä»¶é¸ã€Œå¢å¼·å°æ¯”åº¦ã€
                    </p>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn" onclick="processDocument()">ç¢ºèªåŸ·è¡Œ</button>
                </div>
            </div>


            <!-- çµæœé è¦½å€åŸŸ -->
            <div class="result-section" id="resultSection">
                <h2>âœ… è™•ç†å®Œæˆï¼</h2>
                <p>æ–‡ä»¶å·²æˆåŠŸè£åˆ‡ä¸¦æ ¡æ­£é€è¦–ï¼Œè«‹é è¦½çµæœä¸¦ç¢ºèªä¸‹è¼‰</p>
                
                <div class="canvas-container" style="margin: 20px 0;">
                    <div class="canvas-title" style="text-align: center;">è£åˆ‡çµæœé è¦½</div>
                    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 15px;">
                        <canvas id="resultCanvas" style="max-width: 60%; border: 2px solid #28a745; border-radius: 10px;"></canvas>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button class="btn" onclick="rotateResult()" style="min-width: 120px; padding: 10px;">ğŸ”„ æ—‹è½‰90Â°</button>
                            <div style="font-size: 0.9rem; color: #666; text-align: center;">
                                <span id="rotationAngle">0Â°</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="resetTool()" style="margin-right: 15px;">ğŸ”„ é‡æ–°é–‹å§‹</button>
                    <a href="#" class="download-link" id="downloadLink" download>ğŸ“¥ ä¸‹è¼‰åœ–ç‰‡</a>
                </div>
            </div>

            <!-- è¨Šæ¯é¡¯ç¤ºå€åŸŸ -->
            <div id="messageArea"></div>
        </div>
    </div>

    <!-- è¼‰å…¥è¦†è“‹å±¤ -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p>æ­£åœ¨è¼‰å…¥ OpenCV.js...</p>
        </div>
    </div>

    <!-- OpenCV.js -->
    <script>
        var Module = {
            onRuntimeInitialized() {
                document.getElementById('loadingOverlay').style.display = 'none';
                console.log('OpenCV.js è¼‰å…¥å®Œæˆ');
            }
        };
    </script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let originalImage = null;
        let originalMat = null;
        let detectedCorners = null;
        let currentScale = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragCornerIndex = -1;
        let originalFileName = '';
        let currentRotation = 0; // ç•¶å‰æ—‹è½‰è§’åº¦ (0, 90, 180, 270)

        // æª”æ¡ˆè™•ç†
        function handleDrop(event) {
            event.preventDefault();
            event.target.classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.target.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.target.classList.remove('dragover');
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            if (!file.type.startsWith('image/')) {
                showMessage('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆ', 'error');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                showMessage('æª”æ¡ˆå¤§å°è¶…é 10MB é™åˆ¶', 'error');
                return;
            }

            originalFileName = file.name.replace(/\.[^/.]+$/, "");
            
            const reader = new FileReader();
            reader.onload = function(e) {
                loadImage(e.target.result);
            };
            reader.readAsDataURL(file);
        }

        function loadImage(src) {
            // ç«‹å³æ¸…ç©ºè¼¸å…¥å€åŸŸç•«å¸ƒä»¥ä¿è­·éš±ç§
            clearInputCanvas();
            
            // é¡¯ç¤ºè¼‰å…¥spinner
            document.getElementById('imageLoading').style.display = 'block';
            
            const img = new Image();
            img.onload = function() {
                // ä¿æŒspinneré¡¯ç¤ºï¼Œå°‡åœ¨åµæ¸¬å®Œæˆå¾Œéš±è—
                
                originalImage = img;
                displayOriginalImage();
                showProgress(20, 'åœ–ç‰‡è¼‰å…¥å®Œæˆ');
                
                setTimeout(() => {
                    autoDetect();
                }, 500);
            };
            
            img.onerror = function() {
                // éš±è—è¼‰å…¥spinner
                document.getElementById('imageLoading').style.display = 'none';
                showMessage('åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼', 'error');
            };
            
            img.src = src;
        }
        
        // æ¸…ç©ºè¼¸å…¥å€åŸŸç•«å¸ƒ
        function clearInputCanvas() {
            const detectionCanvas = document.getElementById('detectionCanvas');
            if (detectionCanvas) {
                const ctx = detectionCanvas.getContext('2d');
                ctx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
            
            const resultCanvas = document.getElementById('resultCanvas');
            if (resultCanvas) {
                const ctx = resultCanvas.getContext('2d');
                ctx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            }
            
            // éš±è—è¼‰å…¥spinner
            document.getElementById('imageLoading').style.display = 'none';
            
            // é‡ç½®æ—‹è½‰ç‹€æ…‹
            currentRotation = 0;
            const rotationDisplay = document.getElementById('rotationAngle');
            if (rotationDisplay) {
                rotationDisplay.textContent = '0Â°';
            }
        }

        function displayOriginalImage() {
            // è¨ˆç®—é¡¯ç¤ºå°ºå¯¸
            const maxSize = 400;
            currentScale = Math.min(maxSize / originalImage.width, maxSize / originalImage.height, 1);
            
            // å»ºç«‹ OpenCV Mat
            if (originalMat) originalMat.delete();
            
            // ä½¿ç”¨åŸå§‹å°ºå¯¸å»ºç«‹ Mat
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = originalImage.width;
            fullCanvas.height = originalImage.height;
            const fullCtx = fullCanvas.getContext('2d');
            fullCtx.drawImage(originalImage, 0, 0);
            
            originalMat = cv.imread(fullCanvas);
            
            document.getElementById('canvasSection').style.display = 'block';
        }

        // è‡ªå‹•åµæ¸¬æ–‡ä»¶é‚Šç•Œ
        async function autoDetect() {
            if (!originalMat || typeof cv === 'undefined') {
                showMessage('OpenCV.js å°šæœªè¼‰å…¥å®Œæˆæˆ–åœ–ç‰‡å°šæœªè¼‰å…¥', 'error');
                return;
            }

            try {
                // é¡¯ç¤ºè¼‰å…¥spinner (é©ç”¨æ–¼è§’é»é‡ç½®æ™‚)
                document.getElementById('imageLoading').style.display = 'block';
                showProgress(30, 'é–‹å§‹è‡ªå‹•åµæ¸¬æ–‡ä»¶é‚Šç•Œ...');
                
                // æ­¥é©Ÿ 1: é è™•ç†
                showProgress(40, 'åœ–ç‰‡é è™•ç†ä¸­...');
                const processed = preprocessImage(originalMat);
                
                // æ­¥é©Ÿ 2: é‚Šç·£æª¢æ¸¬
                showProgress(60, 'åŸ·è¡Œå¤šç­–ç•¥é‚Šç·£æª¢æ¸¬...');
                const edges = detectEdges(processed);
                
                // æ­¥é©Ÿ 3: è¼ªå»“æª¢æ¸¬
                showProgress(70, 'åˆ†æè¼ªå»“çµæ§‹...');
                const contours = findContours(edges);
                
                // æ­¥é©Ÿ 4: å››é‚Šå½¢è­˜åˆ¥
                showProgress(80, 'è­˜åˆ¥æœ€ä½³å››é‚Šå½¢...');
                const bestQuad = findBestQuadrilateral(contours);
                
                if (bestQuad) {
                    detectedCorners = bestQuad.corners;
                    showProgress(90, 'å››é‚Šå½¢åµæ¸¬æˆåŠŸï¼');
                    displayDetectionResult();
                    showProgress(100, 'åµæ¸¬å®Œæˆ');
                    
                    setTimeout(() => {
                        document.getElementById('processingSection').style.display = 'none';
                        document.getElementById('manualAdjust').style.display = 'block';
                        // éš±è—è¼‰å…¥spinner
                        document.getElementById('imageLoading').style.display = 'none';
                        showMessage('âœ… è‡ªå‹•åµæ¸¬æˆåŠŸï¼æ‚¨å¯ä»¥æ‰‹å‹•å¾®èª¿è§’é»ä½ç½®æˆ–ç›´æ¥åŸ·è¡Œè£åˆ‡', 'success');
                    }, 1000);
                } else {
                    showProgress(0, '');
                    document.getElementById('processingSection').style.display = 'none';
                    document.getElementById('manualAdjust').style.display = 'block';
                    // éš±è—è¼‰å…¥spinner
                    document.getElementById('imageLoading').style.display = 'none';
                    
                    // æä¾›é è¨­è§’é»
                    detectedCorners = getDefaultCorners();
                    displayDetectionResult();
                    
                    showMessage('âš ï¸ æ‰¾ä¸åˆ°ä¸»é«”è¼ªå»“ï¼Œè«‹æ‰‹å‹•èª¿æ•´å››å€‹è§’é»ä½ç½®', 'warning');
                }
                
                // æ¸…ç†è¨˜æ†¶é«”
                processed.gray.delete();
                processed.blurred.delete();
                processed.enhanced.delete();
                processed.bilateral.delete();
                processed.sharpened.delete();
                edges.delete();
                contours.delete();
                
            } catch (error) {
                console.error('è‡ªå‹•åµæ¸¬éŒ¯èª¤:', error);
                showProgress(0, '');
                document.getElementById('processingSection').style.display = 'none';
                // éš±è—è¼‰å…¥spinner
                document.getElementById('imageLoading').style.display = 'none';
                showMessage('è‡ªå‹•åµæ¸¬å¤±æ•—: ' + error.message, 'error');
            }
        }

        // åœ–ç‰‡é è™•ç† - å¢å¼·ç‰ˆå¤šç­–ç•¥
        function preprocessImage(src) {
            // è½‰ç°éš
            const gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            
            // é«˜æ–¯æ¨¡ç³Šå»å™ª
            const blurred = new cv.Mat();
            const ksize = new cv.Size(5, 5);
            cv.GaussianBlur(gray, blurred, ksize, 0, 0, cv.BORDER_DEFAULT);
            
            // å¢å¼·å°æ¯”åº¦ - é©åº¦å¢å¼·
            const enhanced = new cv.Mat();
            const clahe = new cv.CLAHE(3.0, new cv.Size(8, 8));
            clahe.apply(blurred, enhanced);
            clahe.delete();
            
            // é›™é‚Šæ¿¾æ³¢ - è¼•åº¦è™•ç†
            const bilateral = new cv.Mat();
            cv.bilateralFilter(enhanced, bilateral, 5, 50, 50);
            
            // è¼•åº¦éŠ³åŒ–è™•ç†
            const kernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -0.5, 0, -0.5, 3, -0.5, 0, -0.5, 0]);
            const sharpened = new cv.Mat();
            cv.filter2D(bilateral, sharpened, cv.CV_8U, kernel);
            kernel.delete();
            
            return { gray, blurred, enhanced, bilateral, sharpened };
        }

        // ç°¡åŒ–é‚Šç·£æª¢æ¸¬ - åŸºæœ¬ä½†æœ‰æ•ˆ
        function detectEdges(processed) {
            // æ–¹æ³•1: ç›´æ¥å°ç°éšåœ–ä½¿ç”¨Canny
            const edges1 = new cv.Mat();
            cv.Canny(processed.gray, edges1, 50, 150, 3, false);
            
            // æ–¹æ³•2: å°æ¨¡ç³Šåœ–ä½¿ç”¨Canny
            const edges2 = new cv.Mat();
            cv.Canny(processed.blurred, edges2, 30, 120, 3, false);
            
            // æ–¹æ³•3: è‡ªé©æ‡‰é–¾å€¼ + Canny
            const edges3 = new cv.Mat();
            const thresh = new cv.Mat();
            cv.adaptiveThreshold(processed.blurred, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            cv.Canny(thresh, edges3, 50, 150, 3, false);
            
            // ç°¡å–®åˆä½µ
            const combined = new cv.Mat();
            cv.bitwise_or(edges1, edges2, combined);
            cv.bitwise_or(combined, edges3, combined);
            
            // è¼•å¾®å½¢æ…‹å­¸è™•ç†
            const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
            const dilated = new cv.Mat();
            cv.dilate(combined, dilated, kernel, new cv.Point(-1, -1), 1);
            
            edges1.delete();
            edges2.delete();
            edges3.delete();
            thresh.delete();
            combined.delete();
            kernel.delete();
            
            return dilated;
        }
        
        // æ–¹æ³•1: è‡ªé©æ‡‰é–¾å€¼ + Canny
        function detectEdgesMethod1(src) {
            const thresh = new cv.Mat();
            cv.adaptiveThreshold(src, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            
            const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
            const closed = new cv.Mat();
            cv.morphologyEx(thresh, closed, cv.MORPH_CLOSE, kernel);
            
            const edges = new cv.Mat();
            cv.Canny(closed, edges, 50, 150, 3, false);
            
            const dilated = new cv.Mat();
            cv.dilate(edges, dilated, kernel, new cv.Point(-1, -1), 1);
            
            thresh.delete();
            closed.delete();
            edges.delete();
            kernel.delete();
            
            return dilated;
        }
        
        // æ–¹æ³•2: æº«å’Œ Canny
        function detectEdgesMethod2(src) {
            const edges = new cv.Mat();
            cv.Canny(src, edges, 50, 120, 3, false);
            
            const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
            const dilated = new cv.Mat();
            cv.dilate(edges, dilated, kernel, new cv.Point(-1, -1), 1);
            
            edges.delete();
            kernel.delete();
            
            return dilated;
        }
        
        // æ–¹æ³•3: æº«å’Œ Sobel æ¢¯åº¦
        function detectEdgesMethod3(src) {
            const sobelX = new cv.Mat();
            const sobelY = new cv.Mat();
            const sobel = new cv.Mat();
            
            cv.Sobel(src, sobelX, cv.CV_16S, 1, 0, 3);
            cv.Sobel(src, sobelY, cv.CV_16S, 0, 1, 3);
            
            const absX = new cv.Mat();
            const absY = new cv.Mat();
            cv.convertScaleAbs(sobelX, absX);
            cv.convertScaleAbs(sobelY, absY);
            
            cv.addWeighted(absX, 0.5, absY, 0.5, 0, sobel);
            
            // æº«å’ŒäºŒå€¼åŒ–
            const binary = new cv.Mat();
            cv.threshold(sobel, binary, 80, 255, cv.THRESH_BINARY);
            
            sobelX.delete();
            sobelY.delete();
            sobel.delete();
            absX.delete();
            absY.delete();
            
            return binary;
        }

        // å°‹æ‰¾è¼ªå»“
        function findContours(edges) {
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            
            hierarchy.delete();
            return contours;
        }

        // å¢å¼·ç‰ˆæœ€ä½³å››é‚Šå½¢å°‹æ‰¾ - å¤šç­–ç•¥é©æ‡‰æ€§æª¢æ¸¬
        function findBestQuadrilateral(contours) {
            const imageArea = originalMat.rows * originalMat.cols;
            const centerX = originalMat.cols / 2;
            const centerY = originalMat.rows / 2;
            
            // ç­–ç•¥1: åš´æ ¼æ¨™æº– (é¢ç© > 40%, è§’åº¦æ¥è¿‘90åº¦)
            let bestQuad = findQuadWithStrategy(contours, 'strict', imageArea, centerX, centerY);
            
            // ç­–ç•¥2: å¯¬é¬†æ¨™æº– (é¢ç© > 25%, è§’åº¦å¯¬é¬†)
            if (!bestQuad) {
                bestQuad = findQuadWithStrategy(contours, 'relaxed', imageArea, centerX, centerY);
            }
            
            // ç­–ç•¥3: æœ€å¤§è¼ªå»“é€¼è¿‘ (å–æœ€å¤§è¼ªå»“å˜—è©¦å››é‚Šå½¢é€¼è¿‘)
            if (!bestQuad) {
                bestQuad = findQuadWithStrategy(contours, 'largest', imageArea, centerX, centerY);
            }
            
            return bestQuad;
        }
        
        // ä¾ç­–ç•¥å°‹æ‰¾å››é‚Šå½¢
        function findQuadWithStrategy(contours, strategy, imageArea, centerX, centerY) {
            let bestQuad = null;
            let bestScore = 0;
            let minAreaRatio, maxEpsilon, angleThreshold;
            
            switch (strategy) {
                case 'strict':
                    minAreaRatio = 0.3; // é™ä½å¾40%åˆ°30%
                    maxEpsilon = 0.02;
                    angleThreshold = 35; // æ”¾å¯¬å¾30åº¦åˆ°35åº¦
                    break;
                case 'relaxed':
                    minAreaRatio = 0.25;
                    maxEpsilon = 0.04;
                    angleThreshold = 45;
                    break;
                case 'largest':
                    minAreaRatio = 0.15;
                    maxEpsilon = 0.06;
                    angleThreshold = 60;
                    break;
            }
            
            // å…ˆæŒ‰é¢ç©æ’åºè¼ªå»“
            const sortedContours = [];
            for (let i = 0; i < contours.size(); i++) {
                const contour = contours.get(i);
                const area = cv.contourArea(contour);
                if (area >= imageArea * minAreaRatio) {
                    sortedContours.push({ contour, area, index: i });
                }
            }
            sortedContours.sort((a, b) => b.area - a.area);
            
            // è™•ç†ç¬¦åˆæ¢ä»¶çš„è¼ªå»“
            for (const item of sortedContours) {
                const { contour, area } = item;
                
                // å˜—è©¦ä¸åŒçš„é€¼è¿‘ç²¾åº¦
                const epsilons = strategy === 'largest' ? 
                    [0.02, 0.03, 0.04, 0.05, 0.06] : 
                    [0.02, 0.03, 0.04];
                
                for (const eps of epsilons) {
                    const epsilon = eps * cv.arcLength(contour, true);
                    const approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, epsilon, true);
                    
                    if (approx.rows === 4) {
                        const corners = [];
                        for (let j = 0; j < 4; j++) {
                            const point = approx.intPtr(j, 0);
                            corners.push({ x: point[0], y: point[1] });
                        }
                        
                        // æª¢æŸ¥è§’åº¦æ˜¯å¦åˆç†
                        if (isValidQuadrilateral(corners, angleThreshold)) {
                            const score = evaluateQuadrilateral(corners, area, imageArea, centerX, centerY);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestQuad = {
                                    corners: sortCorners(corners),
                                    area: area,
                                    score: score,
                                    strategy: strategy
                                };
                            }
                        }
                    }
                    
                    approx.delete();
                    
                    if (bestQuad && strategy === 'largest') break; // æ‰¾åˆ°å°±åœæ­¢
                }
                
                if (bestQuad && strategy === 'largest') break;
            }
            
            return bestQuad;
        }
        
        // é©—è­‰å››é‚Šå½¢æœ‰æ•ˆæ€§
        function isValidQuadrilateral(corners, angleThreshold) {
            for (let i = 0; i < 4; i++) {
                const prev = corners[(i + 3) % 4];
                const curr = corners[i];
                const next = corners[(i + 1) % 4];
                
                const angle = calculateAngle(prev, curr, next);
                if (angle < (90 - angleThreshold) || angle > (90 + angleThreshold)) {
                    return false;
                }
            }
            return true;
        }

        // å››é‚Šå½¢è©•åˆ†
        function evaluateQuadrilateral(corners, area, imageArea, centerX, centerY) {
            let score = 0;
            
            // 1. é¢ç©è©•åˆ† (0-40 åˆ†)
            const areaRatio = area / imageArea;
            if (areaRatio > 0.5) score += 40;
            else if (areaRatio > 0.4) score += 30;
            else score += 20;
            
            // 2. ä½ç½®è©•åˆ† (0-30 åˆ†) - ä¸­å¿ƒä½ç½®è¼ƒä½³
            const centerDist = Math.sqrt(
                Math.pow(getCentroid(corners).x - centerX, 2) + 
                Math.pow(getCentroid(corners).y - centerY, 2)
            );
            const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
            score += (1 - centerDist / maxDist) * 30;
            
            // 3. è§’åº¦è©•åˆ† (0-30 åˆ†) - æ¥è¿‘ 90 åº¦è¼ƒä½³
            score += evaluateAngles(corners);
            
            return score;
        }

        // è©•ä¼°è§’åº¦
        function evaluateAngles(corners) {
            let angleScore = 0;
            
            for (let i = 0; i < 4; i++) {
                const prev = corners[(i + 3) % 4];
                const curr = corners[i];
                const next = corners[(i + 1) % 4];
                
                const angle = calculateAngle(prev, curr, next);
                const deviation = Math.abs(angle - 90);
                
                if (deviation < 10) angleScore += 7.5;
                else if (deviation < 20) angleScore += 5;
                else if (deviation < 30) angleScore += 2.5;
            }
            
            return angleScore;
        }

        // è¨ˆç®—è§’åº¦
        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            
            const cos = dot / (mag1 * mag2);
            return Math.acos(Math.max(-1, Math.min(1, cos))) * 180 / Math.PI;
        }

        // è¨ˆç®—è³ªå¿ƒ
        function getCentroid(corners) {
            const x = corners.reduce((sum, p) => sum + p.x, 0) / 4;
            const y = corners.reduce((sum, p) => sum + p.y, 0) / 4;
            return { x, y };
        }

        // è§’é»æ’åº (å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹)
        function sortCorners(corners) {
            const center = getCentroid(corners);
            
            // ä½¿ç”¨è§’åº¦æ’åºï¼Œç„¶å¾Œæ‰¾åˆ°æœ€å·¦ä¸Šçš„é»ä½œç‚ºèµ·å§‹é»
            const cornersWithAngles = corners.map(corner => ({
                ...corner,
                angle: Math.atan2(corner.y - center.y, corner.x - center.x)
            }));
            
            // æŒ‰è§’åº¦æ’åº
            cornersWithAngles.sort((a, b) => a.angle - b.angle);
            
            // æ‰¾åˆ°æœ€å·¦ä¸Šçš„é»ï¼ˆx+yæœ€å°ï¼‰ä½œç‚ºèµ·å§‹é»
            let startIndex = 0;
            let minSum = Infinity;
            
            for (let i = 0; i < 4; i++) {
                const sum = cornersWithAngles[i].x + cornersWithAngles[i].y;
                if (sum < minSum) {
                    minSum = sum;
                    startIndex = i;
                }
            }
            
            // å¾æœ€å·¦ä¸Šçš„é»é–‹å§‹ï¼Œé †æ™‚é‡æ’åˆ—ï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
            const result = [];
            for (let i = 0; i < 4; i++) {
                const index = (startIndex + i) % 4;
                result.push({
                    x: cornersWithAngles[index].x,
                    y: cornersWithAngles[index].y
                });
            }
            
            return result;
        }

        // ç²å–é è¨­è§’é»
        function getDefaultCorners() {
            const margin = Math.min(originalMat.cols, originalMat.rows) * 0.1;
            return [
                { x: margin, y: margin },                                    // å·¦ä¸Š
                { x: originalMat.cols - margin, y: margin },                // å³ä¸Š
                { x: originalMat.cols - margin, y: originalMat.rows - margin }, // å³ä¸‹
                { x: margin, y: originalMat.rows - margin }                 // å·¦ä¸‹
            ];
        }

        // é¡¯ç¤ºæª¢æ¸¬çµæœ
        function displayDetectionResult() {
            const canvas = document.getElementById('detectionCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImage.width * currentScale;
            canvas.height = originalImage.height * currentScale;
            
            // ç¹ªè£½åŸåœ–
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½å››é‚Šå½¢
            if (detectedCorners && detectedCorners.length === 4) {
                ctx.strokeStyle = '#ff4757';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                const scaledCorners = detectedCorners.map(corner => ({
                    x: corner.x * currentScale,
                    y: corner.y * currentScale
                }));
                
                ctx.moveTo(scaledCorners[0].x, scaledCorners[0].y);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(scaledCorners[i].x, scaledCorners[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // æ›´æ–°è§’é»è¼¸å…¥æ¡†
                updateCornerInputs();
                
                // å‰µå»ºå¯æ‹–æ‹½çš„è§’é»æ¨™è¨˜
                createCornerMarkers(scaledCorners);
            }
        }

        // å‰µå»ºè§’é»æ¨™è¨˜
        function createCornerMarkers(scaledCorners) {
            const container = document.getElementById('detectionCanvas').parentElement;
            
            // æ¸…é™¤èˆŠçš„æ¨™è¨˜
            const oldMarkers = container.querySelectorAll('.corner-marker');
            oldMarkers.forEach(marker => marker.remove());
            
            // ç²å– canvas ç›¸å°ä½ç½®
            const canvasRect = document.getElementById('detectionCanvas').getBoundingClientRect();
            canvasOffset = { 
                x: canvasRect.left - container.getBoundingClientRect().left, 
                y: canvasRect.top - container.getBoundingClientRect().top 
            };
            
            scaledCorners.forEach((corner, index) => {
                const marker = document.createElement('div');
                marker.className = 'corner-marker';
                marker.style.left = (canvasOffset.x + corner.x) + 'px';
                marker.style.top = (canvasOffset.y + corner.y) + 'px';
                marker.dataset.index = index;
                
                // æ‹–æ‹½äº‹ä»¶
                marker.addEventListener('mousedown', startDrag);
                
                container.appendChild(marker);
            });
            
            // å…¨åŸŸæ‹–æ‹½äº‹ä»¶
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
        }

        // æ‹–æ‹½é–‹å§‹
        function startDrag(event) {
            isDragging = true;
            dragCornerIndex = parseInt(event.target.dataset.index);
            event.preventDefault();
        }

        // æ‹–æ‹½ä¸­
        function drag(event) {
            if (!isDragging || dragCornerIndex === -1) return;
            
            const container = document.getElementById('detectionCanvas').parentElement;
            const containerRect = container.getBoundingClientRect();
            
            const x = event.clientX - containerRect.left - canvasOffset.x;
            const y = event.clientY - containerRect.top - canvasOffset.y;
            
            // æ›´æ–°æ¨™è¨˜ä½ç½®
            const marker = container.querySelector(`[data-index="${dragCornerIndex}"]`);
            if (marker) {
                marker.style.left = (canvasOffset.x + x) + 'px';
                marker.style.top = (canvasOffset.y + y) + 'px';
            }
            
            // æ›´æ–°è§’é»æ•¸æ“š
            detectedCorners[dragCornerIndex] = {
                x: x / currentScale,
                y: y / currentScale
            };
            
            // é‡æ–°ç¹ªè£½
            displayDetectionResult();
            updateCornerInputs();
        }

        // æ‹–æ‹½çµæŸ
        function endDrag() {
            isDragging = false;
            dragCornerIndex = -1;
        }

        // æ›´æ–°è§’é»è¼¸å…¥æ¡†
        function updateCornerInputs() {
            if (!detectedCorners) return;
            
            detectedCorners.forEach((corner, index) => {
                document.getElementById(`corner${index}x`).value = Math.round(corner.x);
                document.getElementById(`corner${index}y`).value = Math.round(corner.y);
            });
        }

        // å¾è¼¸å…¥æ¡†ç²å–æœ€æ–°è§’é»åº§æ¨™
        function getCurrentCorners() {
            const corners = [];
            for (let i = 0; i < 4; i++) {
                const x = parseInt(document.getElementById(`corner${i}x`).value) || 0;
                const y = parseInt(document.getElementById(`corner${i}y`).value) || 0;
                corners.push({ x, y });
            }
            return corners;
        }

        // è™•ç†æ–‡ä»¶è£åˆ‡
        function processDocument() {
            // ç²å–ç•¶å‰æœ€æ–°çš„è§’é»åº§æ¨™ï¼ˆä¾†è‡ªè¼¸å…¥æ¡†æˆ–æ‹–æ‹½ï¼‰
            const currentCorners = getCurrentCorners();
            
            if (!currentCorners || currentCorners.length !== 4) {
                showMessage('è«‹å…ˆè¨­å®šå››å€‹è§’é»', 'error');
                return;
            }

            try {
                showProgress(20, 'æº–å‚™åŸ·è¡Œé€è¦–è®Šæ›...');
                
                // è¨ˆç®—è¼¸å‡ºå°ºå¯¸
                const outputSize = calculateOutputSize(currentCorners);
                showProgress(40, 'è¨ˆç®—è¼¸å‡ºå°ºå¯¸...');
                
                // åŸ·è¡Œé€è¦–è®Šæ›
                const result = performPerspectiveTransform(currentCorners, outputSize);
                showProgress(70, 'åŸ·è¡Œé€è¦–æ ¡æ­£...');
                
                // è‡ªå‹•æ“ºæ­£
                const corrected = autoOrientate(result);
                showProgress(70, 'è‡ªå‹•æ“ºæ­£åœ–ç‰‡...');
                
                // æ ¹æ“šé¸æ“‡çš„æ ¼å¼é€²è¡Œè™•ç†
                const processedImage = applyOutputFormat(corrected);
                showProgress(90, 'æ‡‰ç”¨è¼¸å‡ºæ ¼å¼...');
                
                // é¡¯ç¤ºé è¦½
                showResultPreview(processedImage);
                
                // ç”¢ç”Ÿä¸‹è¼‰é€£çµ (åŸºæ–¼é¡¯ç¤ºçš„ç•«å¸ƒ)
                setTimeout(() => {
                    updateDownloadLink();
                }, 100);
                showProgress(100, 'è™•ç†å®Œæˆï¼');
                
                setTimeout(() => {
                    document.getElementById('processingSection').style.display = 'none';
                    document.getElementById('resultSection').style.display = 'block';
                    showMessage('âœ… æ–‡ä»¶è™•ç†å®Œæˆï¼è«‹é è¦½çµæœä¸¦ç¢ºèªä¸‹è¼‰', 'success');
                }, 1000);
                
                // æ¸…ç†è¨˜æ†¶é«”
                result.delete();
                corrected.delete();
                processedImage.delete();
                
            } catch (error) {
                console.error('è™•ç†æ–‡ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                showMessage('è™•ç†å¤±æ•—: ' + error.message, 'error');
                showProgress(0, '');
                document.getElementById('processingSection').style.display = 'none';
            }
        }

        // è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        function calculateOutputSize(corners) {
            // è¨ˆç®—å››æ¢é‚Šçš„é•·åº¦
            const widthTop = distance(corners[0], corners[1]);
            const widthBottom = distance(corners[3], corners[2]);
            const heightLeft = distance(corners[0], corners[3]);
            const heightRight = distance(corners[1], corners[2]);
            
            // å–æœ€å¤§å€¼ä½œç‚ºè¼¸å‡ºå°ºå¯¸
            const outputWidth = Math.max(widthTop, widthBottom);
            const outputHeight = Math.max(heightLeft, heightRight);
            
            return { width: Math.round(outputWidth), height: Math.round(outputHeight) };
        }

        // è¨ˆç®—å…©é»è·é›¢
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // åŸ·è¡Œé€è¦–è®Šæ›
        function performPerspectiveTransform(corners, outputSize) {
            console.log('=== é€è¦–è®Šæ›èª¿è©¦ä¿¡æ¯ ===');
            console.log('åŸå§‹è§’é»:', corners);
            console.log('è¼¸å‡ºå°ºå¯¸:', outputSize);
            
            // ç¢ºä¿è§’é»é †åºæ­£ç¢ºï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
            const sortedCorners = ensureCornerOrder(corners);
            console.log('æ’åºå¾Œè§’é»:');
            console.log('å·¦ä¸Šè§’:', sortedCorners[0]);
            console.log('å³ä¸Šè§’:', sortedCorners[1]); 
            console.log('å³ä¸‹è§’:', sortedCorners[2]);
            console.log('å·¦ä¸‹è§’:', sortedCorners[3]);
            
            // é©—è­‰æ’åºæ˜¯å¦æ­£ç¢º
            console.log('é©—è­‰æ’åº:');
            console.log('å·¦ä¸Šè§’æ‡‰è©²æ˜¯æœ€å° x+y:', sortedCorners[0].x + sortedCorners[0].y);
            console.log('å³ä¸‹è§’æ‡‰è©²æ˜¯æœ€å¤§ x+y:', sortedCorners[2].x + sortedCorners[2].y);
            
            // ä¾†æºé»æ•¸çµ„
            const srcPointsArray = [
                sortedCorners[0].x, sortedCorners[0].y,  // å·¦ä¸Š
                sortedCorners[1].x, sortedCorners[1].y,  // å³ä¸Š
                sortedCorners[2].x, sortedCorners[2].y,  // å³ä¸‹
                sortedCorners[3].x, sortedCorners[3].y   // å·¦ä¸‹
            ];
            
            // ç›®æ¨™é»æ•¸çµ„ - ä¿®æ­£åº§æ¨™ç¯„åœ
            const dstPointsArray = [
                0, 0,                                    // å·¦ä¸Š -> (0,0)
                outputSize.width, 0,                     // å³ä¸Š -> (width,0)
                outputSize.width, outputSize.height,     // å³ä¸‹ -> (width,height)
                0, outputSize.height                     // å·¦ä¸‹ -> (0,height)
            ];
            
            console.log('æºé»é™£åˆ—:', srcPointsArray);
            console.log('ç›®æ¨™é»é™£åˆ—:', dstPointsArray);
            
            // å‰µå»º OpenCV çŸ©é™£
            const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, srcPointsArray);
            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, dstPointsArray);
            
            try {
                // è¨ˆç®—é€è¦–è®Šæ›çŸ©é™£
                const transformMatrix = cv.getPerspectiveTransform(srcPoints, dstPoints);
                console.log('é€è¦–è®Šæ›çŸ©é™£è¨ˆç®—æˆåŠŸ');
                
                // åŸ·è¡Œé€è¦–è®Šæ›
                const result = new cv.Mat();
                const outputSizeCv = new cv.Size(outputSize.width, outputSize.height);
                cv.warpPerspective(originalMat, result, transformMatrix, outputSizeCv);
                
                console.log('é€è¦–è®Šæ›åŸ·è¡Œå®Œæˆï¼Œçµæœå°ºå¯¸:', result.cols, 'x', result.rows);
                
                // æ¸…ç†è¨˜æ†¶é«”
                srcPoints.delete();
                dstPoints.delete();
                transformMatrix.delete();
                
                return result;
                
            } catch (error) {
                console.error('é€è¦–è®Šæ›å¤±æ•—:', error);
                srcPoints.delete();
                dstPoints.delete();
                throw error;
            }
        }

        // ç¢ºä¿è§’é»é †åºæ­£ç¢º - ç°¡åŒ–ç‰ˆæœ¬
        function ensureCornerOrder(corners) {
            // ä½¿ç”¨æœ€ç°¡å–®å¯é çš„æ–¹æ³•ï¼šæŒ‰è·é›¢æ’åº
            
            // 1. æ‰¾å·¦ä¸Šè§’ï¼šåˆ°(0,0)è·é›¢æœ€çŸ­
            const topLeft = corners.reduce((min, p) => 
                (p.x + p.y < min.x + min.y) ? p : min);
            
            // 2. æ‰¾å³ä¸‹è§’ï¼šåˆ°åœ–ç‰‡å³ä¸‹è§’è·é›¢æœ€çŸ­ï¼ˆx+yæœ€å¤§ï¼‰
            const bottomRight = corners.reduce((max, p) => 
                (p.x + p.y > max.x + max.y) ? p : max);
            
            // 3. å¾å‰©é¤˜å…©é»ä¸­åˆ†è¾¨å³ä¸Šå’Œå·¦ä¸‹
            const remaining = corners.filter(p => p !== topLeft && p !== bottomRight);
            
            let topRight, bottomLeft;
            if (remaining.length >= 2) {
                // å³ä¸Šè§’ï¼šxå¤§yå° (x-yè¼ƒå¤§)
                topRight = remaining.reduce((max, p) => 
                    (p.x - p.y > max.x - max.y) ? p : max);
                // å·¦ä¸‹è§’ï¼šå‰©ä¸‹çš„é»
                bottomLeft = remaining.find(p => p !== topRight);
            } else {
                topRight = remaining[0] || topLeft;
                bottomLeft = remaining[1] || topLeft;
            }
            
            return [topLeft, topRight, bottomRight, bottomLeft];
        }

        // è‡ªå‹•æ“ºæ­£ - æš«æ™‚åœç”¨è‡ªå‹•æ—‹è½‰
        function autoOrientate(mat) {
            // æš«æ™‚ä¸é€²è¡Œè‡ªå‹•æ—‹è½‰ï¼Œç›´æ¥è¿”å›åŸåœ–
            // é€™æ¨£å¯ä»¥é¿å…æ„å¤–çš„90åº¦æ—‹è½‰
            return mat.clone();
        }

        // æ ¹æ“šé¸æ“‡çš„æ ¼å¼è™•ç†åœ–ç‰‡
        function applyOutputFormat(mat) {
            const selectedFormat = document.querySelector('input[name="outputFormat"]:checked').value;
            
            switch (selectedFormat) {
                case 'original':
                    return mat.clone();
                    
                case 'grayscale':
                    return convertToGrayscale(mat);
                    
                case 'blackwhite':
                    return convertToBlackWhite(mat);
                    
                case 'enhanced':
                    return enhanceContrast(mat);
                    
                default:
                    return mat.clone();
            }
        }

        // è½‰æ›ç‚ºç°éš
        function convertToGrayscale(mat) {
            const gray = new cv.Mat();
            cv.cvtColor(mat, gray, cv.COLOR_BGR2GRAY);
            
            // è½‰å›3é€šé“ä»¥ä¾¿ä¿å­˜ç‚ºå½©è‰²æ ¼å¼
            const grayBgr = new cv.Mat();
            cv.cvtColor(gray, grayBgr, cv.COLOR_GRAY2BGR);
            
            gray.delete();
            return grayBgr;
        }

        // è½‰æ›ç‚ºé»‘ç™½é«˜å°æ¯”ï¼ˆæœ€çœå¢¨æ°´ï¼‰
        function convertToBlackWhite(mat) {
            const gray = new cv.Mat();
            cv.cvtColor(mat, gray, cv.COLOR_BGR2GRAY);
            
            // è‡ªé©æ‡‰é–¾å€¼è™•ç†ï¼Œç”¢ç”Ÿæ¸…æ™°çš„é»‘ç™½æ•ˆæœ
            const binary = new cv.Mat();
            cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            
            // è½‰å›3é€šé“
            const binaryBgr = new cv.Mat();
            cv.cvtColor(binary, binaryBgr, cv.COLOR_GRAY2BGR);
            
            gray.delete();
            binary.delete();
            return binaryBgr;
        }

        // å¢å¼·å°æ¯”åº¦ï¼ˆé©åˆå½©è‰²æ–‡ä»¶ï¼‰
        function enhanceContrast(mat) {
            const enhanced = new cv.Mat();
            
            // è½‰æ›åˆ°LABè‰²å½©ç©ºé–“é€²è¡Œå°æ¯”åº¦å¢å¼·
            const lab = new cv.Mat();
            cv.cvtColor(mat, lab, cv.COLOR_BGR2Lab);
            
            // åˆ†é›¢é€šé“
            const channels = new cv.MatVector();
            cv.split(lab, channels);
            
            // å°Lé€šé“ï¼ˆäº®åº¦ï¼‰é€²è¡ŒCLAHEï¼ˆå°æ¯”åº¦é™åˆ¶è‡ªé©æ‡‰ç›´æ–¹åœ–å‡è¡¡åŒ–ï¼‰
            const clahe = new cv.CLAHE(3.0, new cv.Size(8, 8));
            const lChannel = channels.get(0);
            const enhancedL = new cv.Mat();
            clahe.apply(lChannel, enhancedL);
            
            // é‡æ–°çµ„åˆé€šé“
            const newChannels = new cv.MatVector();
            newChannels.push_back(enhancedL);
            newChannels.push_back(channels.get(1));
            newChannels.push_back(channels.get(2));
            
            cv.merge(newChannels, lab);
            cv.cvtColor(lab, enhanced, cv.COLOR_Lab2BGR);
            
            // æ¸…ç†è¨˜æ†¶é«”
            channels.delete();
            newChannels.delete();
            lChannel.delete();
            enhancedL.delete();
            lab.delete();
            clahe.delete();
            
            return enhanced;
        }

        // é¡¯ç¤ºçµæœé è¦½
        function showResultPreview(mat) {
            const canvas = document.getElementById('resultCanvas');
            
            // è¨ˆç®—é è¦½å°ºå¯¸ (æœ€å¤§ 600px)
            const maxSize = 600;
            const scale = Math.min(maxSize / mat.cols, maxSize / mat.rows, 1);
            
            canvas.width = mat.cols * scale;
            canvas.height = mat.rows * scale;
            
            // å‰µå»ºè‡¨æ™‚ canvas ä¾†ç¸®æ”¾åœ–ç‰‡
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mat.cols;
            tempCanvas.height = mat.rows;
            cv.imshow(tempCanvas, mat);
            
            // ç¹ªè£½ç¸®æ”¾å¾Œçš„é è¦½
            const ctx = canvas.getContext('2d');
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        }

        // ç”¢ç”Ÿä¸‹è¼‰é€£çµ
        function generateDownloadLink(mat) {
            const canvas = document.createElement('canvas');
            cv.imshow(canvas, mat);
            
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.href = url;
                downloadLink.download = `${originalFileName}_update.jpg`;
                
                // æ¸…ç†èˆŠçš„ URL
                if (downloadLink.dataset.oldUrl) {
                    URL.revokeObjectURL(downloadLink.dataset.oldUrl);
                }
                downloadLink.dataset.oldUrl = url;
                
            }, 'image/jpeg', 0.9);
        }

        // é¡¯ç¤ºé€²åº¦
        function showProgress(percentage, text) {
            document.getElementById('processingSection').style.display = 'block';
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('statusText').textContent = text;
        }

        // é¡¯ç¤ºè¨Šæ¯
        function showMessage(message, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            messageArea.innerHTML = '';
            messageArea.appendChild(alertDiv);
            
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 5000);
        }

        // æ—‹è½‰çµæœåœ–ç‰‡
        function rotateResult() {
            const canvas = document.getElementById('resultCanvas');
            if (!canvas || !canvas.getContext) return;
            
            // æ›´æ–°æ—‹è½‰è§’åº¦
            currentRotation = (currentRotation + 90) % 360;
            document.getElementById('rotationAngle').textContent = currentRotation + 'Â°';
            
            // ç²å–ç•¶å‰ç•«å¸ƒå…§å®¹
            const ctx = canvas.getContext('2d');
            
            // å‰µå»ºè‡¨æ™‚ç•«å¸ƒä¿å­˜ç•¶å‰åœ–åƒ
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
            
            // æ—‹è½‰90åº¦éœ€è¦äº¤æ›å¯¬é«˜
            const newWidth = canvas.height;
            const newHeight = canvas.width;
            
            // é‡è¨­ç•«å¸ƒå°ºå¯¸
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // æ¸…ç©ºç•«å¸ƒ
            ctx.clearRect(0, 0, newWidth, newHeight);
            
            // è¨­ç½®æ—‹è½‰è®Šæ› (ä»¥ç•«å¸ƒä¸­å¿ƒç‚ºè»¸å¿ƒ)
            ctx.save();
            ctx.translate(newWidth / 2, newHeight / 2);
            ctx.rotate(Math.PI / 2);
            ctx.translate(-tempCanvas.width / 2, -tempCanvas.height / 2);
            
            // ç¹ªè£½æ—‹è½‰å¾Œçš„åœ–åƒ
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
            
            // æ›´æ–°ä¸‹è¼‰é€£çµ
            updateDownloadLink();
        }
        
        // æ›´æ–°ä¸‹è¼‰é€£çµ
        function updateDownloadLink() {
            const canvas = document.getElementById('resultCanvas');
            if (canvas && canvas.toDataURL) {
                const link = document.getElementById('downloadLink');
                link.href = canvas.toDataURL('image/png');
                link.download = originalFileName + '_update.png';
            }
        }
        
        // é‡ç½®å·¥å…·
        function resetTool() {
            // ç«‹å³æ¸…ç©ºç•«å¸ƒä»¥ä¿è­·éš±ç§
            clearInputCanvas();
            
            // æ¸…ç†è®Šæ•¸
            if (originalMat) originalMat.delete();
            originalMat = null;
            originalImage = null;
            detectedCorners = null;
            originalFileName = '';
            currentRotation = 0; // é‡ç½®æ—‹è½‰è§’åº¦
            
            // é‡ç½®æ—‹è½‰é¡¯ç¤º
            document.getElementById('rotationAngle').textContent = '0Â°';
            
            // éš±è—æ‰€æœ‰å€å¡Š
            document.getElementById('canvasSection').style.display = 'none';
            document.getElementById('manualAdjust').style.display = 'none';
            document.getElementById('processingSection').style.display = 'none';
            document.getElementById('resultSection').style.display = 'none';
            
            // æ¸…ç©ºè¨Šæ¯
            document.getElementById('messageArea').innerHTML = '';
            
            // é‡ç½®æª”æ¡ˆè¼¸å…¥
            document.getElementById('fileInput').value = '';
            
            showMessage('å·¥å…·å·²é‡ç½®ï¼Œè«‹é‡æ–°ä¸Šå‚³åœ–ç‰‡', 'info');
        }

        
        // æ¸…ç†è¨˜æ†¶é«”
        window.addEventListener('beforeunload', function() {
            if (originalMat) originalMat.delete();
        });
    </script>
</body>
</html>